<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>checkasm: Benchmarking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">checkasm<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Assembly testing and benchmarking framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('benchmarking.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Benchmarking </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide explains how to use checkasm's benchmarking capabilities to accurately measure and compare the performance of optimized assembly implementations against reference code.</p>
<h1 class="doxsection"><a class="anchor" id="bench_basic"></a>
Basics</h1>
<h2 class="doxsection"><a class="anchor" id="bench_workflow"></a>
Benchmark Workflow</h2>
<p>Benchmarking in checkasm follows the same structure as correctness testing, with an additional call to <a class="el" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28" title="Benchmark the optimized implementation.">checkasm_bench_new()</a>:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__bufrect.html#ga134be1495ed85b902e0488ff2dfa3cbc">BUF_RECT</a>(uint8_t, src,   64, 64);</div>
<div class="line"><a class="code hl_define" href="group__bufrect.html#ga134be1495ed85b902e0488ff2dfa3cbc">BUF_RECT</a>(uint8_t, dst_c, 64, 64);</div>
<div class="line"><a class="code hl_define" href="group__bufrect.html#ga134be1495ed85b902e0488ff2dfa3cbc">BUF_RECT</a>(uint8_t, dst_a, 64, 64);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="test_8h.html#ac14b1acf6ab5851e8fe157b833dbd0a9">checkasm_declare</a>(<span class="keywordtype">void</span>, uint8_t *dst, ptrdiff_t dst_stride,</div>
<div class="line">                       <span class="keyword">const</span> uint8_t *src, ptrdiff_t src_stride,</div>
<div class="line">                       <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="test_8h.html#af89e132503dee480bf6d778f61046083">checkasm_check_func</a>(dsp-&gt;filter, <span class="stringliteral">&quot;filter_64x64&quot;</span>)) {</div>
<div class="line">    <a class="code hl_define" href="group__bufrect.html#gac6c629870114785925378fe47af16422">INITIALIZE_BUF_RECT</a>(src);</div>
<div class="line">    <a class="code hl_define" href="group__bufrect.html#ga52b49767d86fba82b34eb4b27c58b7d7">CLEAR_BUF_RECT</a>(dst_c);</div>
<div class="line">    <a class="code hl_define" href="group__bufrect.html#ga52b49767d86fba82b34eb4b27c58b7d7">CLEAR_BUF_RECT</a>(dst_a);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Correctness testing</span></div>
<div class="line">    <a class="code hl_define" href="test_8h.html#a22fdeb651a1cc4ecddaef384da98dada">checkasm_call_ref</a>(dst_c, dst_c_stride, src, src_stride, 64, 64);</div>
<div class="line">    <a class="code hl_define" href="test_8h.html#abca61f0321c4258cdc5203c9396fd51a">checkasm_call_new</a>(dst_a, dst_a_stride, src, src_stride, 64, 64);</div>
<div class="line">    <a class="code hl_define" href="group__bufrect.html#ga9f805d46587abb0942eef42455436327">checkasm_check_rect_padded</a>(dst_c, dst_c_stride,</div>
<div class="line">                               dst_a, dst_a_stride, 64, 64, <span class="stringliteral">&quot;dst&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Benchmarking</span></div>
<div class="line">    <a class="code hl_define" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a>(<a class="code hl_define" href="test_8h.html#a6f2afbd0d6c3ba180d49cc9396543463">checkasm_alternate</a>(dst_a, dst_c), dst_a_stride,</div>
<div class="line">                       src, src_stride, 64, 64);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="test_8h.html#a62b0579d89e3dff6c36448d06b393505">checkasm_report</a>(<span class="stringliteral">&quot;filter&quot;</span>);</div>
<div class="ttc" id="agroup__bufrect_html_ga134be1495ed85b902e0488ff2dfa3cbc"><div class="ttname"><a href="group__bufrect.html#ga134be1495ed85b902e0488ff2dfa3cbc">BUF_RECT</a></div><div class="ttdeci">#define BUF_RECT(type, name, w, h)</div><div class="ttdoc">Declare an aligned, padded rectangular buffer.</div><div class="ttdef"><b>Definition</b> utils.h:553</div></div>
<div class="ttc" id="agroup__bufrect_html_ga52b49767d86fba82b34eb4b27c58b7d7"><div class="ttname"><a href="group__bufrect.html#ga52b49767d86fba82b34eb4b27c58b7d7">CLEAR_BUF_RECT</a></div><div class="ttdeci">#define CLEAR_BUF_RECT(name)</div><div class="ttdoc">Clear a rectangular buffer (including padding)</div><div class="ttdef"><b>Definition</b> utils.h:570</div></div>
<div class="ttc" id="agroup__bufrect_html_ga9f805d46587abb0942eef42455436327"><div class="ttname"><a href="group__bufrect.html#ga9f805d46587abb0942eef42455436327">checkasm_check_rect_padded</a></div><div class="ttdeci">#define checkasm_check_rect_padded(rect1,...)</div><div class="ttdoc">Compare two rectangular buffers including padding.</div><div class="ttdef"><b>Definition</b> utils.h:604</div></div>
<div class="ttc" id="agroup__bufrect_html_gac6c629870114785925378fe47af16422"><div class="ttname"><a href="group__bufrect.html#gac6c629870114785925378fe47af16422">INITIALIZE_BUF_RECT</a></div><div class="ttdeci">#define INITIALIZE_BUF_RECT(name)</div><div class="ttdoc">Initialize a rectangular buffer (including padding) with pathological values.</div><div class="ttdef"><b>Definition</b> utils.h:578</div></div>
<div class="ttc" id="atest_8h_html_a012d866e2f2a5f5ede4b9c2765248e28"><div class="ttname"><a href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a></div><div class="ttdeci">#define checkasm_bench_new(...)</div><div class="ttdoc">Benchmark the optimized implementation.</div><div class="ttdef"><b>Definition</b> test.h:401</div></div>
<div class="ttc" id="atest_8h_html_a22fdeb651a1cc4ecddaef384da98dada"><div class="ttname"><a href="test_8h.html#a22fdeb651a1cc4ecddaef384da98dada">checkasm_call_ref</a></div><div class="ttdeci">#define checkasm_call_ref(...)</div><div class="ttdoc">Call the reference implementation.</div><div class="ttdef"><b>Definition</b> test.h:321</div></div>
<div class="ttc" id="atest_8h_html_a62b0579d89e3dff6c36448d06b393505"><div class="ttname"><a href="test_8h.html#a62b0579d89e3dff6c36448d06b393505">checkasm_report</a></div><div class="ttdeci">CHECKASM_API void checkasm_report(const char *name,...) CHECKASM_PRINTF(1</div><div class="ttdoc">Report test outcome for a named group of functions.</div></div>
<div class="ttc" id="atest_8h_html_a6f2afbd0d6c3ba180d49cc9396543463"><div class="ttname"><a href="test_8h.html#a6f2afbd0d6c3ba180d49cc9396543463">checkasm_alternate</a></div><div class="ttdeci">#define checkasm_alternate(a, b)</div><div class="ttdoc">Alternate between two values during benchmarking.</div><div class="ttdef"><b>Definition</b> test.h:423</div></div>
<div class="ttc" id="atest_8h_html_abca61f0321c4258cdc5203c9396fd51a"><div class="ttname"><a href="test_8h.html#abca61f0321c4258cdc5203c9396fd51a">checkasm_call_new</a></div><div class="ttdeci">#define checkasm_call_new(...)</div><div class="ttdoc">Call the implementation being tested with validation.</div><div class="ttdef"><b>Definition</b> test.h:336</div></div>
<div class="ttc" id="atest_8h_html_ac14b1acf6ab5851e8fe157b833dbd0a9"><div class="ttname"><a href="test_8h.html#ac14b1acf6ab5851e8fe157b833dbd0a9">checkasm_declare</a></div><div class="ttdeci">#define checkasm_declare(ret,...)</div><div class="ttdoc">Declare a function signature for testing.</div><div class="ttdef"><b>Definition</b> test.h:162</div></div>
<div class="ttc" id="atest_8h_html_af89e132503dee480bf6d778f61046083"><div class="ttname"><a href="test_8h.html#af89e132503dee480bf6d778f61046083">checkasm_check_func</a></div><div class="ttdeci">#define checkasm_check_func(func,...)</div><div class="ttdoc">Check if a function should be tested and set up function references.</div><div class="ttdef"><b>Definition</b> test.h:76</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="bench_cli"></a>
Running Benchmarks</h2>
<p>Enable benchmarking with the <span class="tt">--bench</span> flag:</p>
<div class="fragment"><div class="line"># Quick benchmark (uses default duration)</div>
<div class="line">./checkasm --bench</div>
<div class="line"> </div>
<div class="line"># Longer benchmark for more accurate results (10ms per function)</div>
<div class="line">./checkasm --bench --duration=10000</div>
<div class="line"> </div>
<div class="line"># Benchmark specific functions only</div>
<div class="line">./checkasm --bench --function=&#39;filter_*&#39;</div>
<div class="line"> </div>
<div class="line"># Verbose output showing all timing measurements</div>
<div class="line">./checkasm --bench --verbose</div>
</div><!-- fragment --><p>The <span class="tt">--duration</span> parameter controls how long (in microseconds) each function is benchmarked. Longer durations provide more accurate results but take more time. The default is typically sufficient for most cases.</p>
<h2 class="doxsection"><a class="anchor" id="bench_export"></a>
Exporting Results</h2>
<p>checkasm can export benchmark results in multiple formats:</p>
<div class="fragment"><div class="line"># CSV format (suitable for spreadsheets)</div>
<div class="line">./checkasm --bench --csv &gt; results.csv           # without column headers</div>
<div class="line">./checkasm --bench --csv --verbose &gt; results.csv # with column headers</div>
<div class="line"> </div>
<div class="line"># JSON format (for programmatic analysis, includes all data)</div>
<div class="line">./checkasm --bench --json &gt; results.json</div>
<div class="line"> </div>
<div class="line"># HTML format (interactive visualizations)</div>
<div class="line">./checkasm --bench --html &gt; results.html</div>
</div><!-- fragment --><p>The JSON output format includes all measurement data and detailed statistical parameters, including kernel density estimates, regression parameters, and confidence intervals. The HTML output displays this same data in the form of interactive charts.</p>
<h1 class="doxsection"><a class="anchor" id="bench_methodology"></a>
Statistical Methodology</h1>
<h2 class="doxsection"><a class="anchor" id="bench_lognormal"></a>
Log-Normal Distribution Modeling</h2>
<p>checkasm models execution time as a log-normal distribution, which is well-suited for performance measurements because:</p>
<ol type="1">
<li>Execution time is always positive</li>
<li>Performance variations tend to be multiplicative (e.g. power states) rather than additive</li>
<li>Outliers (e.g., from cache misses or interrupts) naturally fall into the long tail</li>
</ol>
<p>The statistical estimator tracks two parameters:</p><ul>
<li><b>Log mean</b> (μ): the logarithm of the median execution time</li>
<li><b>Log variance</b> (σ²): the variance of log(execution time)</li>
</ul>
<p>From these, checkasm computes:</p><ul>
<li><b>Mode</b>: most likely execution time = exp(μ - σ²)</li>
<li><b>Median</b>: middle execution time = exp(μ)</li>
<li><b>Mean</b>: average execution time = exp(μ + σ²/2)</li>
<li><b>Standard deviation</b>: sqrt(exp(2μ + σ²) × (exp(σ²) - 1))</li>
<li><b>Upper/Lower 95% confidence intervals</b>: exp(μ ± 1.96 × σ)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="bench_regression"></a>
Linear Regression</h2>
<p>checkasm performs linear regression in log-space on the relationship between iteration count and total execution time:</p>
<div class="fragment"><div class="line">log(per_call_time) = log(total_time) - log(iterations)</div>
</div><!-- fragment --><p>This approach:</p><ul>
<li>Automatically handles the multiplicative nature of timing variations</li>
<li>Provides robust outlier rejection through regression residuals</li>
<li>Separates per-call time from measurement overhead</li>
<li>Computes confidence intervals for the estimates</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="bench_geometric"></a>
Geometric Mean for Multiple Runs</h2>
<p>When <a class="el" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28" title="Benchmark the optimized implementation.">checkasm_bench_new()</a> is called multiple times for the same function (e.g., testing different block sizes), the final reported value is the <b>geometric mean</b> of all measurements:</p>
<div class="fragment"><div class="line">geometric_mean = (x₁ × x₂ × ... × xₙ)^(1/n)</div>
</div><!-- fragment --><p>The geometric mean is appropriate for performance measurements because it:</p><ul>
<li>Is not skewed by outliers as heavily as arithmetic mean</li>
<li>Properly handles ratios and speedups across multiple orders of magnitude</li>
<li>Provides a representative "typical" performance across configurations</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="bench_overhead"></a>
Overhead Correction</h2>
<p>checkasm measures and subtracts the overhead of:</p><ol type="1">
<li>The benchmarking loop itself</li>
<li>The function call mechanism</li>
<li>The timer read operation</li>
</ol>
<p>This is done by measuring a no-op function and subtracting its measured time from all benchmark results. The no-op overhead is reported at startup:</p>
<div class="fragment"><div class="line">- No-op overhead: 2.41 +/- 0.093 cycles per call (provisional)</div>
</div><!-- fragment --><p>For accuracy, this is re-estimated periodically throughout the benchmarking process to account for any drift. The final value is reported again at the end if <span class="tt">--verbose</span> is enabled.</p>
<h1 class="doxsection"><a class="anchor" id="bench_best_practices"></a>
Best Practices</h1>
<h2 class="doxsection"><a class="anchor" id="bp_system_state"></a>
System State</h2>
<p>Despite all of the statistical techniques employed by checkasm to combat short- and medium-term noise, there is an unavoidable dependence on long-term changes in system state. For reliable benchmarking, consider:</p>
<p><b>Power Management:</b></p><ul>
<li>Disable CPU frequency scaling if possible: <div class="fragment"><div class="line"># Linux: set CPU governor to performance mode</div>
<div class="line">sudo cpupower frequency-set --governor performance</div>
<div class="line"> </div>
<div class="line"># Or for all CPUs</div>
<div class="line">for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do</div>
<div class="line">    echo performance | sudo tee $cpu</div>
<div class="line">done</div>
</div><!-- fragment --></li>
<li>Disable turbo boost for consistent results: <div class="fragment"><div class="line"># Intel</div>
<div class="line">echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo</div>
<div class="line"> </div>
<div class="line"># AMD</div>
<div class="line">echo 0 | sudo tee /sys/devices/system/cpu/cpufreq/boost</div>
</div><!-- fragment --></li>
</ul>
<p><b>System Load:</b></p><ul>
<li>Close unnecessary applications</li>
<li>Avoid running benchmarks on heavily loaded systems</li>
<li>Consider using <span class="tt">nice</span> to prioritize the benchmark process: <div class="fragment"><div class="line">nice -n -20 ./checkasm --bench</div>
</div><!-- fragment --></li>
</ul>
<p><b>Thermal Throttling:</b></p><ul>
<li>Ensure adequate cooling to prevent thermal throttling</li>
<li>Allow sufficient cool-down time between benchmark runs</li>
<li>Monitor CPU temperature during long benchmark sessions</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="bp_alignment"></a>
Cache Alignment</h2>
<p>checkasm automatically warms up caches before taking measurements, but you should be aware of cache effects:</p>
<ul>
<li><b>L1/L2 Cache</b>: Most optimized functions should fit in L2 cache</li>
<li><b>Data Working Set</b>: Buffers allocated with <a class="el" href="group__bufrect.html#ga134be1495ed85b902e0488ff2dfa3cbc" title="Declare an aligned, padded rectangular buffer.">BUF_RECT()</a> are properly aligned and sized to avoid cache conflicts. Failure to do so may lead to performance hits from unaligned memory accesses or cache thrashing.</li>
</ul>
<p>For functions with large working sets that don't fit in cache, benchmark results may reflect cache miss behavior, which is often realistic for real-world usage.</p>
<h2 class="doxsection"><a class="anchor" id="bp_alternating"></a>
Buffer Alternation</h2>
<p>Use <a class="el" href="test_8h.html#a6f2afbd0d6c3ba180d49cc9396543463" title="Alternate between two values during benchmarking.">checkasm_alternate()</a> when benchmarking to prevent cache pollution:</p>
<div class="fragment"><div class="line"><span class="comment">// Good: alternates between dst_a and dst_c to prevent cache hits from</span></div>
<div class="line"><span class="comment">// previous iterations</span></div>
<div class="line"><a class="code hl_define" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a>(<a class="code hl_define" href="test_8h.html#a6f2afbd0d6c3ba180d49cc9396543463">checkasm_alternate</a>(dst_a, dst_c), dst_a_stride,</div>
<div class="line">                   src, src_stride, w, h);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Acceptable: always writes to dst_a</span></div>
<div class="line"><a class="code hl_define" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a>(dst_a, dst_a_stride, src, src_stride, w, h);</div>
</div><!-- fragment --><p>Alternating buffers ensures that benchmarks are not stalled by previous access to the same data buffer from the prior loop iteration.</p>
<h2 class="doxsection"><a class="anchor" id="bp_realistic"></a>
Realistic Test Data</h2>
<p>Use realistic input data for benchmarks:</p>
<div class="fragment"><div class="line"><span class="comment">// For general data processing: use INITIALIZE_BUF() which includes common edge cases</span></div>
<div class="line"><a class="code hl_define" href="group__bufrect.html#gac6c629870114785925378fe47af16422">INITIALIZE_BUF_RECT</a>(src);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For specific patterns: use domain-appropriate data</span></div>
<div class="line"><a class="code hl_function" href="group__memory.html#ga2914a7cb52005e18568fa741f512024a">checkasm_randomize_normf</a>(audio_buf, len);  <span class="comment">// Audio: normal distribution</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For worst-case analysis: test pathological inputs</span></div>
<div class="line">generate_worst_case_pattern(buf, len);</div>
<div class="ttc" id="agroup__memory_html_ga2914a7cb52005e18568fa741f512024a"><div class="ttname"><a href="group__memory.html#ga2914a7cb52005e18568fa741f512024a">checkasm_randomize_normf</a></div><div class="ttdeci">CHECKASM_API void checkasm_randomize_normf(float *buf, int width)</div><div class="ttdoc">Fill a float buffer with values from a standard normal distribution.</div></div>
</div><!-- fragment --><p>The input data can significantly affect performance due to:</p><ul>
<li>Data-dependent branches in the implementation</li>
<li>SIMD instruction efficiency varying with data patterns</li>
<li>Cache behavior depending on data values</li>
</ul>
<p>If your function's performance varies significantly with the input data or configuration, consider looping over all such configurations and running <a class="el" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28" title="Benchmark the optimized implementation.">checkasm_bench_new()</a> for each, to measure an overall average.</p>
<h2 class="doxsection"><a class="anchor" id="bp_configurations"></a>
Choosing Configurations</h2>
<p>When benchmarking functions that support multiple sizes or configurations:</p>
<p><b>Option 1: Benchmark all configurations</b> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> w = 4; w &lt;= 128; w &lt;&lt;= 1) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="test_8h.html#af89e132503dee480bf6d778f61046083">checkasm_check_func</a>(dsp-&gt;filter, <span class="stringliteral">&quot;filter_w%d&quot;</span>, w)) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> h = 4; h &lt;= 128; h &lt;&lt;= 1) {</div>
<div class="line">            <span class="comment">// Test for correctness</span></div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Benchmark each configuration</span></div>
<div class="line">            <a class="code hl_define" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a>(dst, dst_stride, src, src_stride, w, h);</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Reports geometric mean of all configurations</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Option 2: Benchmark representative sizes separately</b> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> sizes[][2] = { {16, 16}, {16, 32}, {64, 16}, {64, 32} };</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <span class="keyword">sizeof</span>(sizes) / <span class="keyword">sizeof</span>(sizes[0]); i++) {</div>
<div class="line">    <span class="keywordtype">int</span> w = sizes[i][0], h = sizes[i][1];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Separate check_func call = separate benchmark report</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="test_8h.html#af89e132503dee480bf6d778f61046083">checkasm_check_func</a>(dsp-&gt;filter, <span class="stringliteral">&quot;filter_%dx%d&quot;</span>, w, h)) {</div>
<div class="line">        <span class="comment">// Test for correctness</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_define" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a>(dst, dst_stride, src, src_stride, w, h);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Option 3: Benchmark only the limiting case</b> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> w = 4; w &lt;= 128; w &lt;&lt;= 1) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="test_8h.html#af89e132503dee480bf6d778f61046083">checkasm_check_func</a>(dsp-&gt;filter, <span class="stringliteral">&quot;filter_w%d&quot;</span>, w)) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> h = 4; h &lt;= 128; h &lt;&lt;= 1) {</div>
<div class="line">            <span class="comment">// Test all for correctness</span></div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Benchmark only the largest size</span></div>
<div class="line">        <a class="code hl_define" href="test_8h.html#a012d866e2f2a5f5ede4b9c2765248e28">checkasm_bench_new</a>(dst, dst_stride, src, src_stride, w, 128);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Choose based on your needs:</p><ul>
<li>Option 1: General performance across all sizes</li>
<li>Option 2: Specific performance for important sizes</li>
<li>Option 3: Best-case or worst-case performance</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="bench_interpreting"></a>
Interpreting Results</h1>
<h2 class="doxsection"><a class="anchor" id="interp_output"></a>
Understanding Output</h2>
<p>checkasm's benchmark output provides several pieces of information. Pass <span class="tt">--verbose</span> to see all timing measurements.</p>
<div class="fragment"><div class="line">Benchmark results:</div>
<div class="line">  name                         cycles +/- stddev         time (nanoseconds) (vs ref)</div>
<div class="line">  nop:                            2.4 +/- 0.0             1.2 ns +/- 0.1</div>
<div class="line">  filter_c:                      64.9 +/- 75.4           33.8 ns +/- 40.8</div>
<div class="line">  filter_sse2:                   46.9 +/- 13.3           24.4 ns +/- 7.8    ( 1.22x)</div>
<div class="line">  filter_avx2:                   20.6 +/- 1.2            10.7 ns +/- 1.4    ( 3.15x)</div>
</div><!-- fragment --><p><b>Columns:</b></p><ul>
<li><b>name</b>: Function name (with ISA suffix for optimized versions)</li>
<li><b>cycles</b>: Estimated CPU cycles per call (mean ± standard deviation)</li>
<li><b>time</b>: Estimated nanoseconds per call (mean ± standard deviation)</li>
<li><b>(vs ref)</b>: Speedup relative to the reference (C) implementation</li>
</ul>
<p><b>What to look for:</b></p><ul>
<li>Lower cycle counts indicate better performance</li>
<li>Standard deviation shows measurement reliability</li>
<li>Speedup factors show optimization effectiveness</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="interp_variance"></a>
High Variance</h2>
<p>High standard deviation (large ± values) can indicate:</p>
<ol type="1">
<li><b>System noise</b>: Background processes, interrupts, frequency scaling<ul>
<li>Solution: Follow best practices in <a class="el" href="#bp_system_state">System State</a></li>
</ul>
</li>
<li><b>Data-dependent performance</b>: Function runs faster/slower on different inputs<ul>
<li>This may be legitimate behavior (e.g., early exit conditions)</li>
<li>Consider whether benchmark input is representative</li>
</ul>
</li>
<li><b>Cache effects</b>: Function doesn't fit in cache or has cache conflicts<ul>
<li>May be realistic for large working sets</li>
<li>Ensure buffers are properly aligned</li>
</ul>
</li>
</ol>
<p>The benchmark summary reports average timing error: </p><div class="fragment"><div class="line">- average timing error: 17.371% across 15 benchmarks (maximum 65.404%)</div>
</div><!-- fragment --><p>High maximum error typically indicates at least one very noisy measurement.</p>
<h2 class="doxsection"><a class="anchor" id="interp_comparison"></a>
Comparing Implementations</h2>
<p>When comparing optimized implementations:</p>
<p><b>Absolute speedup:</b> </p><div class="fragment"><div class="line">filter_avx2: 20.6 cycles    ( 3.15x)</div>
</div><!-- fragment --><p> This implementation is 3.15× faster than the C reference.</p>
<p><b>Relative comparison:</b> </p><div class="fragment"><div class="line">filter_sse2: 46.9 cycles    ( 1.22x)</div>
<div class="line">filter_avx2: 20.6 cycles    ( 3.15x)</div>
</div><!-- fragment --><p> AVX2 is 46.9 / 20.6 = 2.28× faster than SSE2.</p>
<h2 class="doxsection"><a class="anchor" id="interp_regression"></a>
Regression Detection</h2>
<p>Use benchmark results to detect performance regressions:</p>
<ol type="1">
<li><b>Baseline measurements</b>: Save benchmark results for your codebase: <div class="fragment"><div class="line">./checkasm --bench --json &gt; baseline.json</div>
</div><!-- fragment --></li>
<li><b>After changes</b>: Run benchmarks again: <div class="fragment"><div class="line">./checkasm --bench --json &gt; current.json</div>
</div><!-- fragment --></li>
<li><b>Compare</b>: Look for functions that got slower<ul>
<li>Small variations (&lt; 5%) are typically noise</li>
<li>Changes &gt; 10% warrant investigation</li>
<li>Changes &gt; 20% are likely real regressions or improvements</li>
</ul>
</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="bench_advanced"></a>
Advanced Topics</h1>
<h2 class="doxsection"><a class="anchor" id="adv_microbench"></a>
Microbenchmarking Pitfalls</h2>
<p>Be aware of common microbenchmarking issues:</p>
<ul>
<li><b>Dead Code Elimination:</b> If the optimized function's results aren't used, the compiler might optimize it away, especially when compiling with link time optimization. This would usually be seen as unrealistically low cycle counts.</li>
<li><b>Constant Folding:</b> Always use <a class="el" href="group__memory.html#gada713cfe880cb426001b9f92faf6f9f1" title="Fill a fixed size buffer with pathological test data (convenience macro)">INITIALIZE_BUF()</a> or <a class="el" href="group__memory.html#ga9b47d3dbddf9465c6bc1a0f34f9cabc9" title="Fill a fixed size buffer wth random data (convenience macro)">RANDOMIZE_BUF()</a> to ensure inputs aren't compile-time constants that could be folded away.</li>
<li><b>Branch Prediction:</b> Running the same code path repeatedly (as benchmarks do) leads to perfect branch prediction, which may not reflect real-world performance that involve mixed function calls (e.g. varying block sizes). This is generally acceptable since you're comparing implementations under the same conditions, but may hide performance gains from e.g. branchless implementations.</li>
<li><b>Memory Hierarchy:</b> Benchmarks often measure L1/L2 cache performance, not DRAM performance. For functions with large working sets, real-world performance may be lower than benchmarks suggest, which puts a bound on the realistically achievable speedup from SIMD optimizations.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="adv_platform"></a>
Platform Considerations</h2>
<h3 class="doxsection"><a class="anchor" id="adv_timer"></a>
Timer Resolution</h3>
<p>checkasm reports timer resolution at startup: </p><div class="fragment"><div class="line">- Timing source: x86 (rdtsc)</div>
<div class="line">- Timing resolution: 0.5976 +/- 0.057 ns/cycle (1644 +/- 156.8 MHz) (provisional)</div>
</div><!-- fragment --><ul>
<li>x86/x86_64: rdtsc (cycle counter) - very high resolution</li>
<li>ARM/AArch64: pmccntr (cycle counter) - high resolution</li>
<li>LoongArch: rdtime (tick counter) - high resolution</li>
<li>PowerPC 64le: mfspr (tick counter) - medium resolution</li>
<li>Other/Fallback: OS-provided timers - lower resolution</li>
</ul>
<p>Lower resolution timers may require longer <span class="tt">--duration</span> for accurate results.</p>
<h3 class="doxsection"><a class="anchor" id="adv_freq_scaling"></a>
Frequency Scaling</h3>
<p>The timer resolution includes clock frequency estimation. If CPU frequency scaling is enabled, this estimate may be inaccurate. However, this affects only the conversion to nanoseconds, not cycle counts. For most accurate results, disable frequency scaling, or compare only raw cycle counts (for platforms with access to high-resolution cycle counters).</p>
<h3 class="doxsection"><a class="anchor" id="adv_cross_platform"></a>
Cross-Platform Comparison</h3>
<p>Comparing cycle counts across different CPUs is meaningful when:</p><ul>
<li>Both CPUs are from the same architecture family</li>
<li>Both run at similar clock speeds</li>
<li>You account for microarchitectural differences</li>
</ul>
<p>For cross-platform comparison, use relative speedup (optimized vs C) rather than absolute cycle counts.</p>
<h2 class="doxsection"><a class="anchor" id="adv_html"></a>
HTML Report Deep Dive</h2>
<p>The HTML report provides detailed statistical visualizations:</p>
<h3 class="doxsection"><a class="anchor" id="adv_kde_regression"></a>
Kernel Density Estimate (left chart)</h3>
<ul>
<li>Shows the probability distribution of execution times</li>
<li>Peak indicates most likely execution time (mode)</li>
<li>Wider distribution = higher variance</li>
<li>Derived from log-normal distribution fit</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="adv_raw_measurements"></a>
Raw Measurements (right chart)</h3>
<ul>
<li>X-axis: iteration count (how many times function was called in one measurement)</li>
<li>Y-axis: total time for all iterations in one measurement</li>
<li>Line: linear regression fit</li>
<li>Shaded area: 95% confidence interval</li>
<li>Points far from line: potential outliers</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="adv_metrics"></a>
Metrics Table</h3>
<ul>
<li><b>Adjusted cycles/time</b>: After overhead subtraction (use this for comparisons)</li>
<li><b>Raw cycles/time</b>: Before overhead subtraction (may be more reliable for sub-10-cycle functions)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="bench_tips"></a>
Tips and Tricks</h1>
<h2 class="doxsection"><a class="anchor" id="tips_reproducible"></a>
Reproducible Benchmarks</h2>
<p>For reproducible results:</p>
<ol type="1">
<li><b>Use fixed random seed</b>: <div class="fragment"><div class="line">./checkasm --bench 12345  # Use seed 12345</div>
</div><!-- fragment --> This ensures the same test data patterns across runs.</li>
<li><b>Document system state</b>:<ul>
<li>CPU model and frequency settings</li>
<li>Compiler version and flags</li>
<li>Operating system and kernel version</li>
<li>checkasm version/commit</li>
</ul>
</li>
<li><b>Multiple runs</b>: Run benchmarks multiple times and verify consistency: <div class="fragment"><div class="line">for i in {1..5}; do</div>
<div class="line">    ./checkasm --bench --function=&#39;filter_*&#39; | tee run_$i.txt</div>
<div class="line">done</div>
</div><!-- fragment --> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
